% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rvine_structure.R
\name{rvine_structure}
\alias{rvine_structure}
\alias{is.rvine_structure}
\alias{as.rvine_structure}
\alias{as.rvine_matrix}
\alias{is.rvine_matrix}
\alias{as.rvine_structure}
\alias{as.rvine_matrix}
\title{R-vine structure}
\usage{
is.rvine_structure(structure)

is.rvine_matrix(matrix)

as.rvine_structure(matrix)

as.rvine_matrix(structure)
}
\arguments{
\item{structure}{an R-vine structure, see \emph{Details}.}

\item{matrix}{an R-vine matrix, see \emph{Details}.}
}
\value{
\code{is.rvine_structure()} throws an error if its input does not define a
valid R-vine structure, otherwise \code{TRUE} is returned invisibly, and
similarly for \code{is.rvine_matrix()}.

\code{as.rvine_structure()} checks whether the input defines a valid r-vine model
and returns an r-vine structure. Similarly, \code{as.rvine_matrix()} converts an
r-vine structure into an r-vine matrix.
}
\description{
R-vine structures are compressed representations encoding the tree
structure of the vine, i.e. the conditioned/conditioning
variables of each edge. They need to satisfy several properties that can be
checked by \code{is.rvine_structure()}, see \emph{Details}.
}
\details{
The R-vine structure is essentially a lower-triangular matrix/triangular array,
with a notation that differs from the one in the VineCopula package.
An example array is\preformatted{1 1 1 1
2 2 2
3 3
4
}

which encodes the following pair-copulas:

\tabular{lll}{
tree \tab  edge \tab pair-copulas   \cr
0    \tab  0    \tab \code{(4, 1)}       \cr
\tab  1    \tab \code{(3, 1)}       \cr
\tab  2    \tab \code{(2, 1)}       \cr
1    \tab  0    \tab \code{(4, 2; 1)}    \cr
\tab  1    \tab \code{(3, 2; 1)}    \cr
2    \tab  0    \tab \code{(4, 3; 2, 1)}
}

An r-vine structure can be converted to an r-vine matrix using
\code{as.rvine_matrix()}, which encodes the same model with a square matrix
filled with zeros. For instance, the matrix corresponding to the structure
above is:\preformatted{1 1 1 1
2 2 2 0
3 3 0 0
4 0 0 0
}

Similarly, an r-vine matrix can be converted to an r-vine structure using
\code{as.rvine_structure()}.

Denoting by \code{M[i, j]} the array entry in row \code{i} and column \code{j} (the
pair-copula index for edge \code{e} in tree \code{t} of a \code{d} dimensional vine is
\code{(M[d - 1 - t, e], M[t, e]; M[t - 1, e], ..., M[0, e])}. Less formally,
\enumerate{
\item Start with the counter-diagonal element of column \code{e} (first conditioned
variable).
\item Jump up to the element in row \code{t} (second conditioned variable).
\item Gather all entries further up in column \code{e} (conditioning set).
}

Internally, the diagonal is stored separately from the off-diagonal elements,
which are stored as a triangular array. For instance, the off-diagonal elements
off the structure above are stored as\preformatted{1 1 1
2 2
3
}

for the structure above. The reason is that it allows for parsimonious
representations of truncated models. For instance, the 2-truncated model
is represented by the same diagonal and the following truncated triangular
array:\preformatted{1 1 1
2 2
}

A valid R-vine structure or matrix must satisfy several conditions which
are checked when \code{is.rvine_structure()} or \code{is.rvine_matrix()} is
called:
\enumerate{
\item It can only contain numbers between 1 and d (and additionally zeros for
r-vine matrices).
\item The anti-diagonal must contain the numbers 1, ..., d.
\item The anti-diagonal entry of a column must not be contained in any
column further to the right.
\item The entries of a column must be contained in all columns to the left.
\item The proximity condition must hold: For all t = 1, ..., d - 2 and
e = 0, ..., d - t - 1 there must exist an index j > d, such that
\code{(M[t, e], {M[0, e], ..., M[t-1, e]})} equals either
\code{(M[d-j-1, j], {M[0, j], ..., M[t-1, j]})} or
\code{(M[t-1, j], {M[d-j-1, j], M[0, j], ..., M[t-2, j]})}.
}

Condition 6 already implies conditions 2-5, but is more difficult to
check by hand.
}
\examples{
mat <- matrix(c(1, 2, 3, 4, 1, 2, 3, 0, 1, 2, 0, 0, 1, 0, 0, 0), 4, 4)
is.rvine_matrix(mat)

# convert to r-vine structure
as.rvine_structure(mat)

# truncate and convert to r-vine structure
mat[3, 1] <- 0
as.rvine_structure(mat)

# throws an error
mat[3, 1] <- 5
try(as.rvine_structure(mat))
try(is.rvine_matrix(mat))

}
